undefined = false--- Extend to allow formatted arguments.-- @param v value to assert-- @param f format-- @param ... arguments to format-- @return valuefunction assert(v, f, ...)	if not v then		error(string.format(f, ...), 2)	end	return vendfunction warnning(v, ...)	if not v then		print("WARNNING:", string.format(...))	end	return vendfunction printf(...)	print(string.format(...))endlocal function _tokey(v)	local tname = type(v)	if tname == "number" then		return string.format("[%d]", v)	elseif tname == "string" then		return string.format("[%q]", v)	end	return string.format("[%s]", tostring(v))endfunction todetailstring(v, nometa, sep, tab, _pre, _loc, _ref)	_pre = _pre or ""	_loc = _loc or "*"	_ref = _ref or {}	_ref[v] = _loc	local str = _pre	local tname = type(v)	if tname == "table" then		local comma = ""		for k, v in pairs(v) do			str = str..comma			comma = ","			str = str..sep..tab.._pre.._tokey(k)..tab.."="			if not _ref[v] then				local tname = type(v)				if tname == "table" or tname == "userdata" then					local _loc = _loc.._tokey(k)					str = str..tab..todetailstring(v, nometa, sep, tab, _pre..tab, _loc, _ref)					_ref[v] = _loc				else					str = str..tab..tostring(v)				end			else				str = str..tab.._ref[v]			end		end		if not nometa then			local _M = getmetatable(v)			if _M then				str = str..sep..tab.._pre.."_M"..tab.."="..tab..todetailstring(_M, nometa, sep, tab, _pre..tab, _loc, _ref)			end		end		if str == "" then			str = "{}"		else			str = "{"..str..sep.._pre.."}"		end	elseif tname == "userdata" then		str = str..tostring(v)		if not nometa then			local _M = getmetatable(v)			if _M then				str = str.." "..todetailstring(_M, nometa, sep, tab, _pre, _loc, _ref)			end		end	else		str = str..tostring(str)	end	return strendfunction toprettystring(v, nometa)	return todetailstring(v, nometa, "\n", "\t")endfunction getfield(v, k)	local tname = type(v)	if tname == "table" then		return rawget(v, k)	elseif tname == "userdata" and getmetatable(v) then		return v[k]	endendlocal __tostring = tostringfunction tostring(v)	local f = getfield(v, "__tostring")	local tname = type(f)	if tname == "string" then		return f	elseif tname == "function" then		return f(v)	else		return __tostring(v)	endendfunction strict(t, rw, _M)	assert(type(t) == "table" and not getmetatable(t), "expect a table without metatable")	assert(string.find(rw, "^r?w?%+?$"), "wrong patterns %q", rw)		_M = _M or {}		local r = string.find(rw, "r")	local w = string.find(rw, "w")	local a = string.find(rw, "%+")		if w then		local t0 = t		t = {}		if r then			rawset(_M, "__index", function(self, key)				local v = t0[key]				if v ~= nil then					return v				end				error("attempt to read undefined memmber '"..key.."' of '"..tostring(self).."'", 2)			end)		end		if not a then			rawset(_M, "__newindex", function(self, key, value)				if t0[key] == nil then					rawset(self, key, value)					return				end				error("attempt to write memmber '"..key.."' of '"..tostring(self).."'", 2)			end)		else			rawset(_M, "__newindex", function(self, key, value)				if t0[key] == nil then					error("attempt to create undefined memmber '"..key.."' of '"..tostring(self).."'", 2)				else					error("attempt to write memmber '"..key.."' of '"..tostring(self).."'", 2)				end			end)		end	else		if r then			rawset(_M, "__index", function(self, key)				error("attempt to read undefined memmber '"..key.."' of '"..tostring(self).."'", 2)			end)		end		if a then			rawset(_M, "__newindex", function(self, key, value)				error("attempt to create undefined memmber '"..key.."' of '"..tostring(self).."'", 2)			end)		end	end	setmetatable(t, _M)	return tend--- Make a shallow copy of a table, including any metatable (for a-- deep copy, use tree.clone).-- @param v any value-- @param nometa if non-nil don't copy metatable-- @return copy of tablefunction clone (v, _ref)	_ref = _ref or {}	_ref[v] = v	local o = v	if getfield(v, "__clone") then		o = v:__clone()	elseif type(v) == "table" then		o = {}		for k, v in pairs(v) do			if _ref[v] then				o[k] = _ref[v]			elseif getfield(v, "__clone") then				local c = v:__clone()				o[k] = c				_ref[v] = c			elseif type(v) == "table" then				local c = clone(v, _ref)				o[k] = c				_ref[v] = c			else				o[k] = v			end		end		setmetatable(o, getmetatable(v))	end	return oend--- An iterator like ipairs, but in reverse.-- @param t table to iterate over-- @return iterator function-- @return the table, as above-- @return #t + 1function rpairs (t)	return function (t, n)					 n = n - 1					 if n > 0 then						 return n, t[n]					 end				 end,	t, #t + 1endfunction spairs(t, f)	local a = {}	for n in pairs(t) do		table.insert(a, n)	end	table.sort(a, f)	local i = 0	local function iter()		i = i + 1		if a[i] == nil then			return nil		else			return a[i], t[a[i]]		end	end	return iterendlocal _NIL = {}function pack(...)	local n = select("#", ...)	local t = {		...	}	for i = 1, n do		if t[i] == nil then			t[i] = _NIL		end	end	return tendfunction unpack(t, i, j)	i = i or 1	j = j or #t	if i > j then		return	end	local v = t[i]	if v == _NIL then		v = nil	end	return v, unpack(t, i + 1, j)endfunction pcall(f, ...)	local args = pack(...)	return xpcall(function() return f(unpack(args)) end, debug.traceback)endrequire "oo_ext"require "string_ext"require "table_ext"require "debug_ext"require "math_ext"